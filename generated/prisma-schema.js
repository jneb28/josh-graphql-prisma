module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.28.1). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregatePlayer {
  count: Int!
}

type AggregatePlayerList {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar Long

type Mutation {
  createPlayer(data: PlayerCreateInput!): Player!
  updatePlayer(data: PlayerUpdateInput!, where: PlayerWhereUniqueInput!): Player
  updateManyPlayers(data: PlayerUpdateManyMutationInput!, where: PlayerWhereInput): BatchPayload!
  upsertPlayer(where: PlayerWhereUniqueInput!, create: PlayerCreateInput!, update: PlayerUpdateInput!): Player!
  deletePlayer(where: PlayerWhereUniqueInput!): Player
  deleteManyPlayers(where: PlayerWhereInput): BatchPayload!
  createPlayerList(data: PlayerListCreateInput!): PlayerList!
  updatePlayerList(data: PlayerListUpdateInput!, where: PlayerListWhereUniqueInput!): PlayerList
  upsertPlayerList(where: PlayerListWhereUniqueInput!, create: PlayerListCreateInput!, update: PlayerListUpdateInput!): PlayerList!
  deletePlayerList(where: PlayerListWhereUniqueInput!): PlayerList
  deleteManyPlayerLists(where: PlayerListWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Player {
  _id: ID!
  name: String!
  wins: Int!
  losses: Int!
  race: String!
}

type PlayerConnection {
  pageInfo: PageInfo!
  edges: [PlayerEdge]!
  aggregate: AggregatePlayer!
}

input PlayerCreateInput {
  name: String!
  wins: Int!
  losses: Int!
  race: String!
}

input PlayerCreateManyInput {
  create: [PlayerCreateInput!]
  connect: [PlayerWhereUniqueInput!]
}

type PlayerEdge {
  node: Player!
  cursor: String!
}

type PlayerList {
  id: ID!
  playerList(where: PlayerWhereInput, orderBy: PlayerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Player!]
}

type PlayerListConnection {
  pageInfo: PageInfo!
  edges: [PlayerListEdge]!
  aggregate: AggregatePlayerList!
}

input PlayerListCreateInput {
  playerList: PlayerCreateManyInput
}

type PlayerListEdge {
  node: PlayerList!
  cursor: String!
}

enum PlayerListOrderByInput {
  id_ASC
  id_DESC
}

type PlayerListPreviousValues {
  id: ID!
}

type PlayerListSubscriptionPayload {
  mutation: MutationType!
  node: PlayerList
  updatedFields: [String!]
  previousValues: PlayerListPreviousValues
}

input PlayerListSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PlayerListWhereInput
  AND: [PlayerListSubscriptionWhereInput!]
}

input PlayerListUpdateInput {
  playerList: PlayerUpdateManyInput
}

input PlayerListWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  playerList_some: PlayerWhereInput
  AND: [PlayerListWhereInput!]
}

input PlayerListWhereUniqueInput {
  id: ID
}

enum PlayerOrderByInput {
  _id_ASC
  _id_DESC
  name_ASC
  name_DESC
  wins_ASC
  wins_DESC
  losses_ASC
  losses_DESC
  race_ASC
  race_DESC
}

type PlayerPreviousValues {
  _id: ID!
  name: String!
  wins: Int!
  losses: Int!
  race: String!
}

input PlayerScalarWhereInput {
  _id: ID
  _id_not: ID
  _id_in: [ID!]
  _id_not_in: [ID!]
  _id_lt: ID
  _id_lte: ID
  _id_gt: ID
  _id_gte: ID
  _id_contains: ID
  _id_not_contains: ID
  _id_starts_with: ID
  _id_not_starts_with: ID
  _id_ends_with: ID
  _id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  wins: Int
  wins_not: Int
  wins_in: [Int!]
  wins_not_in: [Int!]
  wins_lt: Int
  wins_lte: Int
  wins_gt: Int
  wins_gte: Int
  losses: Int
  losses_not: Int
  losses_in: [Int!]
  losses_not_in: [Int!]
  losses_lt: Int
  losses_lte: Int
  losses_gt: Int
  losses_gte: Int
  race: String
  race_not: String
  race_in: [String!]
  race_not_in: [String!]
  race_lt: String
  race_lte: String
  race_gt: String
  race_gte: String
  race_contains: String
  race_not_contains: String
  race_starts_with: String
  race_not_starts_with: String
  race_ends_with: String
  race_not_ends_with: String
  AND: [PlayerScalarWhereInput!]
  OR: [PlayerScalarWhereInput!]
  NOT: [PlayerScalarWhereInput!]
}

type PlayerSubscriptionPayload {
  mutation: MutationType!
  node: Player
  updatedFields: [String!]
  previousValues: PlayerPreviousValues
}

input PlayerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PlayerWhereInput
  AND: [PlayerSubscriptionWhereInput!]
}

input PlayerUpdateDataInput {
  name: String
  wins: Int
  losses: Int
  race: String
}

input PlayerUpdateInput {
  name: String
  wins: Int
  losses: Int
  race: String
}

input PlayerUpdateManyDataInput {
  name: String
  wins: Int
  losses: Int
  race: String
}

input PlayerUpdateManyInput {
  create: [PlayerCreateInput!]
  update: [PlayerUpdateWithWhereUniqueNestedInput!]
  upsert: [PlayerUpsertWithWhereUniqueNestedInput!]
  delete: [PlayerWhereUniqueInput!]
  connect: [PlayerWhereUniqueInput!]
  set: [PlayerWhereUniqueInput!]
  disconnect: [PlayerWhereUniqueInput!]
  deleteMany: [PlayerScalarWhereInput!]
  updateMany: [PlayerUpdateManyWithWhereNestedInput!]
}

input PlayerUpdateManyMutationInput {
  name: String
  wins: Int
  losses: Int
  race: String
}

input PlayerUpdateManyWithWhereNestedInput {
  where: PlayerScalarWhereInput!
  data: PlayerUpdateManyDataInput!
}

input PlayerUpdateWithWhereUniqueNestedInput {
  where: PlayerWhereUniqueInput!
  data: PlayerUpdateDataInput!
}

input PlayerUpsertWithWhereUniqueNestedInput {
  where: PlayerWhereUniqueInput!
  update: PlayerUpdateDataInput!
  create: PlayerCreateInput!
}

input PlayerWhereInput {
  _id: ID
  _id_not: ID
  _id_in: [ID!]
  _id_not_in: [ID!]
  _id_lt: ID
  _id_lte: ID
  _id_gt: ID
  _id_gte: ID
  _id_contains: ID
  _id_not_contains: ID
  _id_starts_with: ID
  _id_not_starts_with: ID
  _id_ends_with: ID
  _id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  wins: Int
  wins_not: Int
  wins_in: [Int!]
  wins_not_in: [Int!]
  wins_lt: Int
  wins_lte: Int
  wins_gt: Int
  wins_gte: Int
  losses: Int
  losses_not: Int
  losses_in: [Int!]
  losses_not_in: [Int!]
  losses_lt: Int
  losses_lte: Int
  losses_gt: Int
  losses_gte: Int
  race: String
  race_not: String
  race_in: [String!]
  race_not_in: [String!]
  race_lt: String
  race_lte: String
  race_gt: String
  race_gte: String
  race_contains: String
  race_not_contains: String
  race_starts_with: String
  race_not_starts_with: String
  race_ends_with: String
  race_not_ends_with: String
  AND: [PlayerWhereInput!]
}

input PlayerWhereUniqueInput {
  _id: ID
}

type Query {
  player(where: PlayerWhereUniqueInput!): Player
  players(where: PlayerWhereInput, orderBy: PlayerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Player]!
  playersConnection(where: PlayerWhereInput, orderBy: PlayerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PlayerConnection!
  playerList(where: PlayerListWhereUniqueInput!): PlayerList
  playerLists(where: PlayerListWhereInput, orderBy: PlayerListOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PlayerList]!
  playerListsConnection(where: PlayerListWhereInput, orderBy: PlayerListOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PlayerListConnection!
  node(id: ID!): Node
}

type Subscription {
  player(where: PlayerSubscriptionWhereInput): PlayerSubscriptionPayload
  playerList(where: PlayerListSubscriptionWhereInput): PlayerListSubscriptionPayload
}
`
      }
    