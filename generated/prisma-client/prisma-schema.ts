// Code generated by Prisma (prisma@1.29.2). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregatePlayer {
  count: Int!
}

type AggregateRealm {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar Long

type Mutation {
  createPlayer(data: PlayerCreateInput!): Player!
  updatePlayer(data: PlayerUpdateInput!, where: PlayerWhereUniqueInput!): Player
  updateManyPlayers(data: PlayerUpdateManyMutationInput!, where: PlayerWhereInput): BatchPayload!
  upsertPlayer(where: PlayerWhereUniqueInput!, create: PlayerCreateInput!, update: PlayerUpdateInput!): Player!
  deletePlayer(where: PlayerWhereUniqueInput!): Player
  deleteManyPlayers(where: PlayerWhereInput): BatchPayload!
  createRealm(data: RealmCreateInput!): Realm!
  updateRealm(data: RealmUpdateInput!, where: RealmWhereUniqueInput!): Realm
  updateManyRealms(data: RealmUpdateManyMutationInput!, where: RealmWhereInput): BatchPayload!
  upsertRealm(where: RealmWhereUniqueInput!, create: RealmCreateInput!, update: RealmUpdateInput!): Realm!
  deleteRealm(where: RealmWhereUniqueInput!): Realm
  deleteManyRealms(where: RealmWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Player {
  _id: ID!
  name: String!
  wins: Int!
  losses: Int!
  race: String!
  realm: Realm!
}

type PlayerConnection {
  pageInfo: PageInfo!
  edges: [PlayerEdge]!
  aggregate: AggregatePlayer!
}

input PlayerCreateInput {
  name: String!
  wins: Int!
  losses: Int!
  race: String!
  realm: RealmCreateOneWithoutPopulationInput!
}

input PlayerCreateManyWithoutRealmInput {
  create: [PlayerCreateWithoutRealmInput!]
  connect: [PlayerWhereUniqueInput!]
}

input PlayerCreateWithoutRealmInput {
  name: String!
  wins: Int!
  losses: Int!
  race: String!
}

type PlayerEdge {
  node: Player!
  cursor: String!
}

enum PlayerOrderByInput {
  _id_ASC
  _id_DESC
  name_ASC
  name_DESC
  wins_ASC
  wins_DESC
  losses_ASC
  losses_DESC
  race_ASC
  race_DESC
}

type PlayerPreviousValues {
  _id: ID!
  name: String!
  wins: Int!
  losses: Int!
  race: String!
}

input PlayerScalarWhereInput {
  _id: ID
  _id_not: ID
  _id_in: [ID!]
  _id_not_in: [ID!]
  _id_lt: ID
  _id_lte: ID
  _id_gt: ID
  _id_gte: ID
  _id_contains: ID
  _id_not_contains: ID
  _id_starts_with: ID
  _id_not_starts_with: ID
  _id_ends_with: ID
  _id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  wins: Int
  wins_not: Int
  wins_in: [Int!]
  wins_not_in: [Int!]
  wins_lt: Int
  wins_lte: Int
  wins_gt: Int
  wins_gte: Int
  losses: Int
  losses_not: Int
  losses_in: [Int!]
  losses_not_in: [Int!]
  losses_lt: Int
  losses_lte: Int
  losses_gt: Int
  losses_gte: Int
  race: String
  race_not: String
  race_in: [String!]
  race_not_in: [String!]
  race_lt: String
  race_lte: String
  race_gt: String
  race_gte: String
  race_contains: String
  race_not_contains: String
  race_starts_with: String
  race_not_starts_with: String
  race_ends_with: String
  race_not_ends_with: String
  AND: [PlayerScalarWhereInput!]
  OR: [PlayerScalarWhereInput!]
  NOT: [PlayerScalarWhereInput!]
}

type PlayerSubscriptionPayload {
  mutation: MutationType!
  node: Player
  updatedFields: [String!]
  previousValues: PlayerPreviousValues
}

input PlayerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PlayerWhereInput
  AND: [PlayerSubscriptionWhereInput!]
}

input PlayerUpdateInput {
  name: String
  wins: Int
  losses: Int
  race: String
  realm: RealmUpdateOneRequiredWithoutPopulationInput
}

input PlayerUpdateManyDataInput {
  name: String
  wins: Int
  losses: Int
  race: String
}

input PlayerUpdateManyMutationInput {
  name: String
  wins: Int
  losses: Int
  race: String
}

input PlayerUpdateManyWithoutRealmInput {
  create: [PlayerCreateWithoutRealmInput!]
  delete: [PlayerWhereUniqueInput!]
  connect: [PlayerWhereUniqueInput!]
  set: [PlayerWhereUniqueInput!]
  disconnect: [PlayerWhereUniqueInput!]
  update: [PlayerUpdateWithWhereUniqueWithoutRealmInput!]
  upsert: [PlayerUpsertWithWhereUniqueWithoutRealmInput!]
  deleteMany: [PlayerScalarWhereInput!]
  updateMany: [PlayerUpdateManyWithWhereNestedInput!]
}

input PlayerUpdateManyWithWhereNestedInput {
  where: PlayerScalarWhereInput!
  data: PlayerUpdateManyDataInput!
}

input PlayerUpdateWithoutRealmDataInput {
  name: String
  wins: Int
  losses: Int
  race: String
}

input PlayerUpdateWithWhereUniqueWithoutRealmInput {
  where: PlayerWhereUniqueInput!
  data: PlayerUpdateWithoutRealmDataInput!
}

input PlayerUpsertWithWhereUniqueWithoutRealmInput {
  where: PlayerWhereUniqueInput!
  update: PlayerUpdateWithoutRealmDataInput!
  create: PlayerCreateWithoutRealmInput!
}

input PlayerWhereInput {
  _id: ID
  _id_not: ID
  _id_in: [ID!]
  _id_not_in: [ID!]
  _id_lt: ID
  _id_lte: ID
  _id_gt: ID
  _id_gte: ID
  _id_contains: ID
  _id_not_contains: ID
  _id_starts_with: ID
  _id_not_starts_with: ID
  _id_ends_with: ID
  _id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  wins: Int
  wins_not: Int
  wins_in: [Int!]
  wins_not_in: [Int!]
  wins_lt: Int
  wins_lte: Int
  wins_gt: Int
  wins_gte: Int
  losses: Int
  losses_not: Int
  losses_in: [Int!]
  losses_not_in: [Int!]
  losses_lt: Int
  losses_lte: Int
  losses_gt: Int
  losses_gte: Int
  race: String
  race_not: String
  race_in: [String!]
  race_not_in: [String!]
  race_lt: String
  race_lte: String
  race_gt: String
  race_gte: String
  race_contains: String
  race_not_contains: String
  race_starts_with: String
  race_not_starts_with: String
  race_ends_with: String
  race_not_ends_with: String
  realm: RealmWhereInput
  AND: [PlayerWhereInput!]
}

input PlayerWhereUniqueInput {
  _id: ID
}

type Query {
  player(where: PlayerWhereUniqueInput!): Player
  players(where: PlayerWhereInput, orderBy: PlayerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Player]!
  playersConnection(where: PlayerWhereInput, orderBy: PlayerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PlayerConnection!
  realm(where: RealmWhereUniqueInput!): Realm
  realms(where: RealmWhereInput, orderBy: RealmOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Realm]!
  realmsConnection(where: RealmWhereInput, orderBy: RealmOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RealmConnection!
  node(id: ID!): Node
}

type Realm {
  _id: ID!
  name: String!
  population(where: PlayerWhereInput, orderBy: PlayerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Player!]
}

type RealmConnection {
  pageInfo: PageInfo!
  edges: [RealmEdge]!
  aggregate: AggregateRealm!
}

input RealmCreateInput {
  name: String!
  population: PlayerCreateManyWithoutRealmInput
}

input RealmCreateOneWithoutPopulationInput {
  create: RealmCreateWithoutPopulationInput
  connect: RealmWhereUniqueInput
}

input RealmCreateWithoutPopulationInput {
  name: String!
}

type RealmEdge {
  node: Realm!
  cursor: String!
}

enum RealmOrderByInput {
  _id_ASC
  _id_DESC
  name_ASC
  name_DESC
}

type RealmPreviousValues {
  _id: ID!
  name: String!
}

type RealmSubscriptionPayload {
  mutation: MutationType!
  node: Realm
  updatedFields: [String!]
  previousValues: RealmPreviousValues
}

input RealmSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RealmWhereInput
  AND: [RealmSubscriptionWhereInput!]
}

input RealmUpdateInput {
  name: String
  population: PlayerUpdateManyWithoutRealmInput
}

input RealmUpdateManyMutationInput {
  name: String
}

input RealmUpdateOneRequiredWithoutPopulationInput {
  create: RealmCreateWithoutPopulationInput
  update: RealmUpdateWithoutPopulationDataInput
  upsert: RealmUpsertWithoutPopulationInput
  connect: RealmWhereUniqueInput
}

input RealmUpdateWithoutPopulationDataInput {
  name: String
}

input RealmUpsertWithoutPopulationInput {
  update: RealmUpdateWithoutPopulationDataInput!
  create: RealmCreateWithoutPopulationInput!
}

input RealmWhereInput {
  _id: ID
  _id_not: ID
  _id_in: [ID!]
  _id_not_in: [ID!]
  _id_lt: ID
  _id_lte: ID
  _id_gt: ID
  _id_gte: ID
  _id_contains: ID
  _id_not_contains: ID
  _id_starts_with: ID
  _id_not_starts_with: ID
  _id_ends_with: ID
  _id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  population_some: PlayerWhereInput
  AND: [RealmWhereInput!]
}

input RealmWhereUniqueInput {
  _id: ID
}

type Subscription {
  player(where: PlayerSubscriptionWhereInput): PlayerSubscriptionPayload
  realm(where: RealmSubscriptionWhereInput): RealmSubscriptionPayload
}
`